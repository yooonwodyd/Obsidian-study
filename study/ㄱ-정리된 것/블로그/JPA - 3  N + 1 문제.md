

N+1 문제는 하나의 쿼리를 통해 데이터를 조회할 때 추가적으로 N개의 쿼리가 실행되는 비효율적인 데이터 조회가 발생하는 문제를 말한다. 

JPA - 2의 글에서도 간단하게 설명했는데, 이를 다시 요약하면 다음과 같다.

1. Team 엔티티는 필드에 List<"User"> 를 가지고 있다.
2. Team 과 User 엔티티는 OneToMany 관계로 매핑되어있다.
3. 이때 팀 A에 속하는 모든 유저 정보를 가져올 때, N개의 쿼리가 추가로 발생한다.
4. 이것이 싫다면 Proxy + Lazy Loading을 통해 필요한 경우에만 추가적인 쿼리를 날릴 수 있다.

그렇다면 Lazy Loading 만으로 N + 1 문제를 해결한 것일까?
어느정도 해결 할 수는 있지만, 완벽하게 해결했다고 볼 수는 없다.(결국에 데이터가 필요할 땐 N번의 쿼리가 추가적으로 발생한다.) 또한 어째서 Eager Loading시에 join을 하지 않는지 등에 대한 의문도 남아있다.

이번 글에선 이러한 의문점들을 해결함 과 동시에 다른 해결방법들을 제시하는 걸 목표로 한다.

### Eager Loading 의 Join에 대해

Eager Loading은 연관된 모든 엔티티들을 데이터베이스에서 불러온다. 
재밌는 점은 OneToOne, ManyToOne, OneToMany 등 어떤 매핑 전략을 쓰느냐에 따라 쿼리문이 달라진 다는 것이다.

### 컬렉션 필드의 Join

우선, JPA의 경우 구현 방식에 따라 다르지만 대부분의 경우 컬렉션 필드는 Join을 사용하는 대신 각 데이터를 가져오는 별도의 쿼리가 발생한다.

join을 사용하지 않는 이유를 간단하게 설명하면 **중복되는 데이터**에  있다.

### 1. 중복되는 데이터

JPA는 데이터베이스에서 가져온 데이터를 객체로 변환하는 과정이 필요하다.
이때 Join으로 가져온 테이블이 다음과 같을 때, 우리는 동일성 보장 문제를 겪는다.

| Team ID | Team Name | User ID | User Name |
| ------- | --------- | ------- | --------- |
| 1       | A 팀       | 101     | User 1    |
| 1       | A 팀       | 102     | User 2    |
| 1       | B 팀       | 103     | User 3    |

현재 Team Name이 동일한 A팀을 두 번 영속성 컨텍스트에 올리는 것은 잘못되었다고 할 수 있다. 두 A팀은 객체 관점에서는 같기 때문이다.  때문에 1. Team이 영속성 컨텍스트에 존재하는지 확인하고, 2. 없으면 Team도 매핑, 있으면 User를 매핑하는 작업이 필요하다.

뿐만 아니라 메모리에 중복 된 데이터가 올라가 있는 만큼, 데이터 셋의 양이 많아지는 만큼 메모리 부하가 생긴다.
때문에 대부분의 JPA 구현체들은 OneToMany에서 컬렉션을 조회할때 개별 쿼리로 조회한다고 한다.



### FetchJoin
N + 1 문제에 대한 해결법으로 가장 많이 등장하는 건 FetchJoin이다.

우선 FetchJoin에 대한 설명은 다음과 같다.

> 패치 조인은 JPQL에서 연관된 엔티티를 한 번의 쿼리로 함께 로딩하기 위해 사용하는 방법입니다. 이는 SQL의 JOIN과 유사하지만, 추가적으로 연관된 엔티티를 영속성 컨텍스트에 함께 로딩하는 기능을 제공합니다.

결국 패치 조인도 매핑 오버헤드가 존재한다. Join을 하는 이상 중복되는 데이터는 생길 수 밖에 없다. 다만 
매번 중복되는 루트 엔티티가 영속성 컨텍스트에 존재하는지 확인하는 작업이 Join과 다르게 존재하지 않기 때문에, 약간의 오버헤드 감소가 있다고 한다.

따라서 FetchJoin의 경우 컬렉션 필드를 개별 쿼리로 가져오던걸 join으로 가져오는 것과 크게 다르지 않다.

### GraphJoin
그래프 조인의 경우 FetchJoin을 어노테이션으로 사용할 수 있게 해주는 것이다.
다만 여러 이유로 내부적으로 Left Outer Join을 사용하는데, 이는 Inner Join을 사용하는 Fetcch Join 보다 약간의 오버헤드를 가지게 된다. 또한 얻는 이점에 비해 복잡성이 많이 상승하고, 개인적으로는 선호하지 않는 방법.




