

N+1 문제는 하나의 쿼리를 통해 데이터를 조회할 때 추가적으로 N개의 쿼리가 실행되는 비효율적인 데이터 조회가 발생하는 문제를 말한다. 

JPA - 2의 글에서도 간단하게 설명했는데, 이를 다시 요약하면 다음과 같다.

1. Team 엔티티는 필드에 List<"User"> 를 가지고 있다.
2. Team 과 User 엔티티는 OneToMany 관계로 매핑되어있다.
3. 이때 팀 A에 속하는 모든 유저 정보를 가져올 때, N개의 쿼리가 추가로 발생한다.
4. 이것이 싫다면 Proxy + Lazy Loading을 통해 필요한 경우에만 추가적인 쿼리를 날릴 수 있다.

그렇다면 Lazy Loading 만으로 N + 1 문제를 해결한 것일까?
어느정도 해결 할 수는 있지만, 완벽하게 해결했다고 볼 수는 없다.(결국에 데이터가 필요할 땐 N번의 쿼리가 추가적으로 발생한다.) 또한 어째서 Eager Loading시에 join을 하지 않는지 등에 대한 의문도 남아있다.

이번 글에선 이러한 의문점들을 해결함 과 동시에 다른 해결방법들을 제시하는 걸 목표로 한다.

### Eager Loading 의 Join에 대해

Eager Loading은 연관된 모든 엔티티들을 데이터베이스에서 불러온다. 
재밌는 점은 OneToOne, ManyToOne, OneToMany 등 어떤 매핑 전략을 쓰느냐에 따라 쿼리문이 달라진 다는 것이다.

### 컬렉션 필드의 Join

우선, JPA의 경우 구현 방식에 따라 다르지만 대부분의 경우 컬렉션 필드는 Join을 사용하는 대신 각 데이터를 가져오는 별도의 쿼리가 발생한다.

그 이유를 간단하게 설명하면 **1. 중복되는 데이터가 많아진다. ** 이다.

### 1. 중복되는 데이터로 인한 메모리 부하


JPA는 데이터베이스에서 가져온 데이터를 객체로 변환하는 과정이 필요하다.
이때 Join으로 가져온 테이블이 다음과 같을 때, 우리는 동일성 보장 문제를 겪는다.

| Team ID | Team Name | User ID | User Name |
| ------- | --------- | ------- | --------- |
| 1       | A 팀       | 101     | User 1    |
| 1       | A 팀       | 102     | User 2    |
| 1       | B 팀       | 103     | User 3    |

현재 Team Name이 동일한 A팀을 두 번 영속성 컨텍스트에 올리는 것은 잘못되었다고 할 수 있다. 두 A팀은 객체 관점에서는 같기 때문이다.  때문에 1. Team이 영속성 컨텍스트에 존재하는지 확인하고, 2. 없으면 Team도 매핑, 있으면 User를 매핑하는 작업이 필요하다.

만약 개별 쿼리를 사용했다면, 중복되는 Team을 매핑할 피룡는 없었을 것이다.






