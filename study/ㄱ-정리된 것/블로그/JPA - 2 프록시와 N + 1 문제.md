
지난 글에서 엔티티 매니저와 영속성 컨텍스트에 대해 설명했다. 
이번에는 이어서 영속성 컨텍스트에서 관리되는 프록시 객체와 객체 그래프 탐색시에 발생할 수 있는 N + 1 문제에 대해 이야기해보겠다.



## 왜 프록시 객체가 필요할까?

JPA를 사용하다보면 객체들끼리 복잡한 연관관계를 가지게 된다. 이때 필드에 List<"User">를 가진 엔티티를 상상해보면 해당 엔티티를 불러오기 위해 몇 천명, 몇 만명일지 모르는 유저 리스트를 데이터베이스에서 같이 꺼내와야하는 상황이 발생한다. 실제로 사용할 필드가 아니라고 해도 말이다.


때문에 모양만 비슷한 가짜(proxy) 객체를 만들어서 사용하는 방법을 떠올렸다.
이를 통해 JPA에서 어떠한 엔티티를 불러올떄, **데이터를 사용할 때까지 데이터베이스 조회를 지연시키는 ** 것이 가능해졌다.

### 그렇다면 프록시 객체는 무엇인가?

프록시 객체는 실제 엔티티를 대체하는 가짜(proxy) 객체이다. 이 객체는 **실제 엔티티에 대한 참조**를 가지고 있으며, **실제 엔티티 클래스의 서브클래스** 이다. 또한 Lazy Loading 설정시에만 사용되며, Eager Loading 시에는 실제 엔티티 인스턴스가 반환된다.

이를 하나씩 보면 다음과 같다.

###  1. 실제 엔티티에 대한 참조를 가지고 있다.

프록시 객체는 실제 엔티티의 식별자(ID)만 가지고 있다. 다시 말해 데이터베이스에서 해당 entity의 식별자ID값만 select해서 가져온 것을 의미한다.


### 2. 실제 엔티티 클래스의 서브클래스이다.
**상속**을 통해 생성된 **하위 클래스**를 의미한다.
프록시 객체는 여러 메서드들의 재정의하여 지연 로딩을 위해 필요한 로직을 추가로 포함하고 있다.. 이를 통해 getter와 같이 데이터베이스 조회가 필요한 메서드가 실행될때, db의 데이터를 조회할 수 있다.
이떄 가져오는 데이터는 설정에 따라 해당 필드만 select해서 가져올 수 있지만, 대게 모든 필드를 select 해온다.

### 3. Lazy Loading 설정시에만 사용된다.
위에서 말했듯이 

N+1 문제는 하나의 쿼리를 통해 데이터를 조회할 때 추가적으로 N개의 쿼리가 실행되는 비효율적인 데이터 조회 문제를 의미한다.

직접 쿼리문을 작성한다면 발생하지 않을 문제이지만, ORM을 통해 객체 그래프 탐색을 진행한다면 N + 1 문제가 발생할 수 있다.

다른 수 많은 글에서 볼 수 있듯이, N + 1 문제는 @OneToMany 일때 많이 발생하며 Lazy Loading을 토해 어느정도 해결 할 수 있다.