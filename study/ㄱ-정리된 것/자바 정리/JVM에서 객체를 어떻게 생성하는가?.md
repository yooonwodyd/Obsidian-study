
### 자바의 런타임 메모리 영역

자바의 런타임 메모리 영역은 다음과 같이 나눌 수 있다.
프로세스의 시작과 동시에 만들어지는 영역도 있고, 쓰레드의 시작과 종료에 맞춰서 생성/삭제되는 영역도 있다. 
\
1. **메서드 영역 (Method Area)**
    - JVM이 시작될 때 생성되며 JVM이 종료될 때까지 유지된다.
    - 가비지 컬렉션에 의해 관리된다.
    - 클래스 데이터, 메서드 코드, 상수 풀, 필드, 메서드 데이터 등을 저장하는 공간이다. 
    - 모든 스레드에서 공유되는 영역으로, 클래스가 로드될 때 클래스와 관련된 모든 정적 정보가 이 영역에 저장된다.
2. **힙 영역 (Heap Area)**
	- 객체가 동적으로 할당되는 메모리 공간 
	- 모든 스레드가 공유하며, 클래스 인스턴스와 배열이 저장된다.
    - JVM이 시작할 때 생성되며, 프로그램 실행 중 객체가 생성될 때마다 메모리를 할당한다.
    - 가비지 컬렉션이 더이상 참조되지 않는 객체를 메모리에서 해제한다.
- **가상 머신 스택 (JVM Stack)**
    - JVM 스택은 각 스레드마다 별도로 존재하는 메모리 영역이다.
    -  메서드 호출 시 생성되는 프레임(로컬 변수, 연산 스택, 호출자 정보 등을 포함하는)들을 저장한다.
    - 각 메서드 호출 시마다 새로운 스택 프레임이 생성되고, 메서드가 종료되면 해당 프레임이 스택에서 제거됩니다.
    - 스택 오버플로우가 발생 할 수 있다.
    - 스택 영역은 **스레드별로 독립적**이며, 메모리 크기는 일반적으로 제한적이다.
- **네이티브 메서드 스택 (Native Method Stack)**
    - 네이티브 코드(C/C++ 등)로 구현된 메서드를 호출할 때 사용된다...일반적으로 자바 프로그램이 JNI를 통해 네이티브 라이브러리를 호출할 때 사용된다.
    - 각 스레드마다 네이티브 메서드 스택이 별도로 존재한다.
    - 네이티브 메서드 호출 시 이 스택에 네이티브 코드의 메서드 호출과 관련된 정보가 저장된다.
- **프로그램 카운터(PC) 레지스터 (Program Counter Register)**
    - 현재 실행 중인 명령의 주소를 가리키는 작은 메모리 공간. 일반적인 프로그램 카운터 이다. 각 스레드마다 독립적인 PC 레지스터를 가지고 있다.


- **클래스 로딩 시점**:
    - JVM은 프로그램이 실행되거나, 특정 클래스가 처음으로 참조될 때 그 클래스를 **클래스 로더(ClassLoader)**를 통해 메모리에 로드된다.
    - 이때, 클래스 내부에 정의된 **`static` 변수와 메서드**는 클래스 로딩 단계에서 메모리의 **메서드 영역(Method Area, 또는 클래스 영역)**에 할당된다.
    - 따라서, 객체가 생성되기 전에라도 `static` 변수와 메서드에 접근할 수 있다.


### 객체가 생성되는 과정

JVM이 new 명령에 해당하는 바이트코드를 만나면, 이 명령의 매개 변수가 상수 풀 안의 클래스를 가리키는 심벌 참조인지 확인한다. 이후 이 심벌 참조가 뜻하는 클래스가 로딩,해석,초기화가 되었는지 확인한다.
만약 되어있지 않다면 로딩을 먼저 시작한다. 로딩이 완료되어있다면 새 객체를 ㄷ

### 클래스 로더와 리플렉션
JVM은 클래스 로더를 사용해 클래스의 정보를 가져와 JVM 메모리에 저장한다.

일반적으로 메소드를 호출한다면, 컴파일 시점에 분석된 클래스를 사용하지만 리플렉션은 **런타임에 클래스를 분석하므로 속도가 느리다**. JVM을 최적화할 수 없기 때문이라고 한다. 그리고 이런 특징으로 인해 **타입 체크가 컴파일 타임에 불가능**하다. 또한 **객체의 추상화가 깨진다**는 단점도 존재한다.

따라서 일반적인 웹 애플리케이션 개발자는 사실 리플렉션을 사용할일이 거의 없다. 보통 라이브러리나 프레임워크를 개발할 때 사용된다. 따라서 **정말 필요한 곳에만 리플렉션을 한정적으로 사용**해야한다.