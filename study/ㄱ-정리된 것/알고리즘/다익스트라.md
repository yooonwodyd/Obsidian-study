### 사고의 흐름
1. 특정 노드에서 다른 노드까지의 최단거리를 찾는 알고리즘
2. `O(E log V)`의 시간복잡도를 가진다. 
3. 따라서 만약 간선의 개수가 많다면 다음을 고려할 수 있다.
	1. heapq가 아닌 배열을 사용한 다익스트라를 사용
	2. 플로이드 워셜 알고리즘 사용. 음의 사이클이 존재하면 제대로 작동하지 않는다.

4. 우선 각 노드까지의 최단거리를 저장할 distance를 만든다. 
5. 탐색할 때 사용할 hq를 만든다.
6. 


```python
import sys
from heapq import heappop, heappush
input = sys.stdin.readline


def dijkstra():
    Q = [(0, 1, 1)]  
    D = [[i, 1e10] for i in range(N + 1)]
    visit = set()

    cnt = -1 
    ans = []
    while Q:
        cost, curV, preV = heappop(Q)
        if curV in visit: continue
        visit.add(curV)
        cnt += 1
        ans.append((preV, curV))

        for neiCost, neiV in adj[curV]:
            if D[neiV][1] > cost + neiCost:
                heappush(Q, (cost + neiCost, neiV, curV))
                D[neiV][0], D[neiV][1] = curV, cost + neiCost

    return cnt, ans


N, M = map(int, input().split())
adj = [[] for _ in range(N + 1)]
for _ in range(M):
    A, B, C = map(int, input().split())
    adj[A].append((C, B))
    adj[B].append((C, A))


cnt, ans = dijkstra()
print(cnt)
for a, b in ans:
    if a == b == 1: continue
    print(a, b)
```