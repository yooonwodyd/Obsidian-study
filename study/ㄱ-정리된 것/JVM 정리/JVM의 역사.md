
우선 JVM에 대해 설명하기 전에 컴파일러에 대해 간단하게 설명하고 넘어가겠다.

C의 경우에는 중간에 바이트 코드 없이 기계어로 번역된다.
JAVA의 경우 바이트 코드로 번역하고, 바이트 코드를 다시 기계어로 번역하는데, 다시 말해 컴파일러가 두 개 필요하다.

Java의 javac 컴파일러가 Java 소스 코드를 Java 바이트코드(.class 파일)로 컴파일한다. 

이 바이트코드는 플랫폼 독립적이기 때문에, 다양한 운영체제와 하드웨어에서 동일하게 사용할 수 있다.

### 아니 굳이 바이트 코드를 둘 필요가 있나요? 어차피 컴파일 뒤에서 한 번 더하는데 귀찮게 컴파일 두개 할 필요가 있음?

만약에 JAVA 문법이 변했는데, 각 OS의 컴파일러를 모두 변경해야 하는 일이 생기는 걸 방지 하기 위해 바이트 코드가 존재한다고 이해하면 편하다.

바이트 코드가 존재하면 javac 컴파일러의 바이트 코드만 변경하면 된다.


### 1.  썬 클래식 VM

처음의 VM인 썬 클래식 VM은 인터프리터 방식으로만 작동했다.

컴파일러는 모든 소스 코드를 한 번에 올린 뒤에, 최적화를 진행하는데, 당시의 메모리 크기에서는 오버헤드가 발생하기 쉬웠고, 때문에 인터프리터 방식으로만 작동했다.

물론 최적화를 위해 컴파일러에 대한 수요도 존재했다. 다만 당시의 JIT 컴파일러는 가상 머신의 시스템 전체가 JIT 컴파일러에 넘어가면 인터프리터와 같이 사용하지 못했다. 때문에 코드 전체를 컴파일 해야했는데, 초기 로드 시간이 너무 길어지는 단점이 존재했다. 

#### 아니 굳이 JIT(just in time) 컴파일러를 써야함? 그냥 컴파일 해서 최적화 하면 되잖아?
문제는 가비지 컬렉터와 다형성 때문에 런타임에 메소드를 결정하는 일이 많다는 것.

### 2. Exact VM
이그젝트 VM 부터 컴파일러와 인터프리터의 혼합, 핫스팟을 이용한 최적화 등이 나왔다.
특히 핸들을 사용한 메모리 방식을 사용하지 않았는데, 이에 대해선 바로 다음에 자세히 설명하겠습니다.

### 3. 핫스팟 VM
핫스팟.(문자 그대로 자주 사용되는 블럭을 hotSpot으로 표현한 것.) 사용해서 런타임 시에 최적화를 할 수 있었고, 현재 가장 널리 쓰이는 자바 VM 이다.
간단하게 만 설명하고, 이후에 핫스팟이 어떻게 작동하는지 보며 자세히 설명하겠다.

### 번외: JIT 컴파일러에 대해
JIT 컴파일러가 제 성능을 내기 위해선 핫스팟을 탐지하는 시간이 필요하다.
하지만 마이크로 서비스가 대두되는 시대에, 자바의 이러한 특징은 단점으로 다가온다.
또한 간단한 프로그램을 실행시키려고 해도 JVM을 메모리에 올려야하고, 가비지 컬렉터를 사용해야하는 등 100MB가 넘는 JRE가 필요하다는 것 또한 단점이다.

이를 해결하기 위해 AOT(ahead of time) 컴파일러, JIT 컴파일러와 대비되는 컴파일러 기술을 사용하기도 하는데, 위에서 말했듯이 "한 번 작성되면 어디서든 실행된다." 라는 자바의 특징을 유지하기 어려워진다.

 이런 단점을 보안해서 서브스트레이트 VM이 탄생했는데, 간단한 코드의 경우 Node.js 보다 메모리를 덜 사용하는 등 다양한 발전을 이루었다.

JVM을 공부하다 보면 시대가 요구하는 기술에 따라 JVM이 변화하고 있음을 느낄 수 있을 것이다. 





